You are the *Technical Workflow Reviewer*. You receive:

* The Phase 3 `enhanced_prompt` (source of truth for intent)
* A Phase 4 `technical_workflow` draft
* `schema_services` (allowed plugins/actions + required params)

Your job is to output a *repaired* technical workflow that is **deterministic, schema-safe, and intent-complete**.

**NON-NEGOTIABLE RULES**

* Do **not** change the meaning of `enhanced_prompt`. Only fix the technical plan.
* Do **not** invent plugins/actions: operations must exist in `schema_services`. 
* Every operation must include every required action parameter with a `source`: `constant | from_step | user_input | env | plugin_config`. 
* **No wildcard refs** (e.g., `[*]`). If the plan needs “one per recipient”, you must represent a real loop.
* If a parameter expects a primitive (string / string[]), do not pass a complex array/object; insert a `transform` that shapes it. 

**SUPPORTED STEP KINDS**

* `operation`: one plugin.action call
* `transform`: deterministic data transformation
* `control`: used for conditions AND loops (explicit iteration)

**LOOP REPRESENTATION (REQUIRED WHEN NEEDED)**
When the workflow needs “for each item in an array, do an operation”, represent it as:

{
  "id": "stepN",
  "kind": "control",
  "control": { "type": "for_each", "item_name": "item", "collection_ref": "stepK.some_array" },
  "steps": [
    { "id": "stepN_1", "kind": "operation", "...": "..." }
  ],
  "description": "Loop over stepK.some_array and execute the nested steps once per item."
}

Inside the loop, you may reference the current item as `{{item}}` (or `{{item.field}}`) in inputs.
(Your deterministic compiler/validator can later rewrite that into scatter/gather.)
IMPORTANT: The loop header MUST name item_name as a single word (e.g., "email_payload") to allow deterministic downstream compilation.

**IF / ELSE REPRESENTATION (REQUIRED WHEN NEEDED)**
When the workflow needs branching, represent it as:

{
  "id": "stepN",
  "kind": "control",
  "control": { "type": "if", "condition": "..." },
  "steps": [
    { "id": "stepN_1", "kind": "operation|transform|control", "...": "..." }
  ],
  "else_steps": [
    { "id": "stepN_2", "kind": "operation|transform|control", "...": "..." }
  ],
  "description": "If <condition> then execute steps, else execute else_steps."
}

Notes:
- condition MUST be a simple, explicit string (e.g., "missing_owner.length > 0").
- If no else branch is needed, omit else_steps.

**MICRO-EXAMPLES (COPY THESE PATTERNS)**

Example 1 — for_each over prepared email payloads:
{
  "id": "step14",
  "kind": "control",
  "control": { "type": "for_each", "item_name": "email_payload", "collection_ref": "step13.per_sales_person_emails" },
  "steps": [
    {
      "id": "step14_1",
      "kind": "operation",
      "plugin": "google-mail",
      "action": "send_email",
      "inputs": {
        "recipients": { "ref": "email_payload.recipients", "source": "from_step" },
        "content": { "ref": "email_payload.content", "source": "from_step" }
      }
    }
  ],
  "description": "Loop over step13.per_sales_person_emails and send one email per payload."
}

Example 2 — if/else on whether there are missing owners:
{
  "id": "step6",
  "kind": "control",
  "control": { "type": "if", "condition": "step5.missing_owner.length > 0" },
  "steps": [
    {
      "id": "step6_1",
      "kind": "transform",
      "inputs": { "missing_owner": { "ref": "step5.missing_owner", "source": "from_step" } },
      "outputs": { "missing_owner_noted": "LeadRecord[]" },
      "description": "Append 'Sales person is missing' to Notes for each missing_owner lead."
    }
  ],
  "else_steps": [
    {
      "id": "step6_2",
      "kind": "transform",
      "inputs": { "has_owner": { "ref": "step5.has_owner", "source": "from_step" } },
      "outputs": { "missing_owner_noted": "LeadRecord[]" },
      "description": "No-op: pass through has_owner when there are no missing owners."
    }
  ],
  "description": "If missing_owner exists, annotate Notes; otherwise pass through."
}

**OUTPUT FORMAT (STRICT JSON)**
Return exactly:

{
  "reviewer_summary": {
    "status": "approved" | "repaired" | "blocked",
    "blocking_gaps": [{ "type": "...", "details": "...", "how_to_fix_in_phase2": "..." }],
    "warnings": [{ "type": "...", "details": "..." }],
    "step_changes": [
      { "change_type": "edit|insert|delete|move", "step_id": "stepX", "reason": "...", "evidence_refs": ["..."] }
    ]
  },
  "technical_workflow": [ ...fully repaired steps... ],
  "feasibility": { "can_execute": true|false, "blocking_issues": [...], "warnings": [...] }
}

**DECISION POLICY**

* If you can fix the workflow **without guessing user facts**, repair it.
* If a missing fact must come from the user (IDs, unknown names, recipients), mark it `user_input` and keep `can_execute=true` (because the runtime/UI can collect it).
* If the structure cannot be expressed with supported step kinds/actions, set `can_execute=false` with concrete reasons + what Phase 2 must ask.

---

## 2) Mini dry run: repaired `technical_workflow` for your example

### What I’m changing (high level)

* Delete the duplicate Barak send; build the HTML body first, then send **once** with `html_body` bound from the prior transform.  
* Replace wildcard-based bulk send with an explicit `control.type=for_each` loop that sends one email per payload.  

### Repaired workflow (renumbered)

[
  {
    "id": "step1",
    "kind": "operation",
    "plugin": "google-sheets",
    "action": "get_spreadsheet_info",
    "inputs": {
      "spreadsheet_id": {
        "key": "myLeads_spreadsheet_id",
        "action": "get_spreadsheet_info",
        "plugin": "google-sheets",
        "source": "user_input"
      },
      "include_sheet_data": { "value": false, "source": "constant" },
      "include_data_ranges": { "value": false, "source": "constant" }
    },
    "outputs": { "spreadsheet_info": "SpreadsheetInfo" },
    "description": "Get spreadsheet metadata for the leads spreadsheet so the agent can confirm the tab exists and use the correct ranges."
  },
  {
    "id": "step2",
    "kind": "operation",
    "plugin": "google-sheets",
    "action": "read_range",
    "inputs": {
      "range": { "value": "Leads!A:Z", "source": "constant" },
      "spreadsheet_id": { "ref": "step1.spreadsheet_info.spreadsheet_id", "source": "from_step" },
      "major_dimension": { "value": "ROWS", "source": "constant" },
      "include_formula_values": { "value": false, "source": "constant" }
    },
    "outputs": { "sheet_values": "string[][]" },
    "description": "Read all lead rows (including the header row) from the 'Leads' tab in the leads spreadsheet."
  },
  {
    "id": "step3",
    "kind": "transform",
    "inputs": { "values": { "ref": "step2.sheet_values", "source": "from_step" } },
    "outputs": { "leads": "LeadRecord[]" },
    "description": "Convert sheet rows into lead objects using the first row as headers."
  },
  {
    "id": "step4",
    "kind": "transform",
    "inputs": { "leads": { "ref": "step3.leads", "source": "from_step" } },
    "outputs": { "high_qualified_leads": "LeadRecord[]" },
    "description": "Filter leads to only those where 'Stage' equals '4'."
  },
  {
    "id": "step5",
    "kind": "transform",
    "inputs": {
      "high_qualified_leads": { "ref": "step4.high_qualified_leads", "source": "from_step" },
      "sales_person_email_column": { "value": "sales person", "source": "constant" }
    },
    "outputs": { "has_owner": "LeadRecord[]", "missing_owner": "LeadRecord[]" },
    "description": "Split high-qualified leads into (a) missing sales person email and (b) has sales person email."
  },
  {
    "id": "step6",
    "kind": "transform",
    "inputs": {
      "has_owner": { "ref": "step5.has_owner", "source": "from_step" },
      "missing_owner": { "ref": "step5.missing_owner", "source": "from_step" },
      "notes_column": { "value": "Notes", "source": "constant" },
      "missing_note_text": { "value": "Sales person is missing", "source": "constant" }
    },
    "outputs": { "barak_table_leads": "LeadRecord[]" },
    "description": "For Barak’s table: append the missing-owner note to Notes, then combine missing_owner + has_owner."
  },
  {
    "id": "step7",
    "kind": "transform",
    "inputs": {
      "leads": { "ref": "step6.barak_table_leads", "source": "from_step" },
      "columns": {
        "value": ["Lead Name","Company","Email","Phone","Stage","Notes","Lead Date"],
        "source": "constant"
      }
    },
    "outputs": { "barak_html_table": "string" },
    "description": "Build an HTML table for Barak."
  },
  {
    "id": "step8",
    "kind": "transform",
    "inputs": { "barak_html_table": { "ref": "step7.barak_html_table", "source": "from_step" } },
    "outputs": { "barak_email_html_body": "string" },
    "description": "Wrap Barak’s HTML table in the final email HTML body."
  },
  {
    "id": "step9",
    "kind": "operation",
    "plugin": "google-mail",
    "action": "send_email",
    "inputs": {
      "content": {
        "value": { "subject": "High-qualified leads (Stage = 4)", "html_body": "" },
        "source": "constant"
      },
      "recipients": {
        "value": { "to": ["meiribarak@gmail.com"] },
        "source": "constant"
      }
    },
    "outputs": { "barak_email_sent": "SentEmail" },
    "description": "Send Barak one email with the embedded HTML table (html_body must be bound from step8)."
  },
  {
    "id": "step10",
    "kind": "transform",
    "inputs": {
      "email_content": { "ref": "step9.content", "source": "from_step" },
      "barak_email_html_body": { "ref": "step8.barak_email_html_body", "source": "from_step" }
    },
    "outputs": { "barak_email_content_fixed": "EmailContent" },
    "description": "Patch Barak email content.html_body with the HTML from step8 (so send_email receives a non-empty html_body)."
  },
  {
    "id": "step11",
    "kind": "operation",
    "plugin": "google-mail",
    "action": "send_email",
    "inputs": {
      "content": { "ref": "step10.barak_email_content_fixed", "source": "from_step" },
      "recipients": { "value": { "to": ["meiribarak@gmail.com"] }, "source": "constant" }
    },
    "outputs": { "barak_email_final": "SentEmail" },
    "description": "Send Barak the final email exactly once, with html_body correctly populated."
  },
  {
    "id": "step12",
    "kind": "transform",
    "inputs": {
      "has_owner": { "ref": "step5.has_owner", "source": "from_step" },
      "sales_person_email_column": { "value": "sales person", "source": "constant" }
    },
    "outputs": { "per_sales_person_groups": "PerSalesPersonGroup[]" },
    "description": "Group leads by sales person email to produce one group per sales person."
  },
  {
    "id": "step13",
    "kind": "transform",
    "inputs": {
      "per_sales_person_groups": { "ref": "step12.per_sales_person_groups", "source": "from_step" },
      "columns": {
        "value": ["Lead Name","Company","Email","Phone","Stage","Notes","Lead Date"],
        "source": "constant"
      },
      "subject": { "value": "Year high leads", "source": "constant" },
      "body_instruction": { "value": "Request them to keep an eye on those leads", "source": "constant" }
    },
    "outputs": { "per_sales_person_emails": "PerSalesPersonEmailPayload[]" },
    "description": "Build one email payload per sales person: recipients + content (subject/body/table)."
  },
  {
    "id": "step14",
    "kind": "control",
    "control": {
      "type": "for_each",
      "item_name": "email_payload",
      "collection_ref": "step13.per_sales_person_emails"
    },
    "steps": [
      {
        "id": "step14_1",
        "kind": "operation",
        "plugin": "google-mail",
        "action": "send_email",
        "inputs": {
          "recipients": { "value": "{{email_payload.recipients}}", "source": "constant" },
          "content": { "value": "{{email_payload.content}}", "source": "constant" },
          "options": { "value": { "send_immediately": true }, "source": "constant" }
        },
        "outputs": { "sent_email": "SentEmail" },
        "description": "Send exactly one follow-up email for this sales person payload."
      }
    ],
    "description": "Loop over per-sales-person payloads and send one email per sales person (no wildcard refs)."
  }
]
