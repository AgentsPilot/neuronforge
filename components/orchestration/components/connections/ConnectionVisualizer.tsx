import React, { useRef, useEffect, useState, useMemo } from 'react';
import { Connection, ConnectionPoint } from '../../types/connections';
import { WorkflowStep } from '../../types/workflow';
import { Trash2, Settings, Zap, Eye, EyeOff } from 'lucide-react';

interface ConnectionVisualizerProps {
  steps: WorkflowStep[];
  connections: Connection[];
  onConnectionClick?: (connection: Connection) => void;
  onConnectionRemove?: (connectionId: string) => void;
  onConnectionHover?: (connection: Connection | null) => void;
  showLabels?: boolean;
  showAnimations?: boolean;
  className?: string;
}

interface StepPosition {
  x: number;
  y: number;
  width: number;
  height: number;
}

export const ConnectionVisualizer: React.FC<ConnectionVisualizerProps> = ({
  steps,
  connections,
  onConnectionClick,
  onConnectionRemove,
  onConnectionHover,
  showLabels = true,
  showAnimations = true,
  className = ''
}) => {
  const svgRef = useRef<SVGSVGElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [stepPositions, setStepPositions] = useState<StepPosition[]>([]);
  const [hoveredConnection, setHoveredConnection] = useState<string | null>(null);
  const [selectedConnection, setSelectedConnection] = useState<string | null>(null);

  // Calculate step positions
  useEffect(() => {
    if (!containerRef.current) return;

    const container = containerRef.current;
    const containerRect = container.getBoundingClientRect();
    const stepWidth = 280;
    const stepHeight = 200;
    const horizontalSpacing = 100;
    const verticalSpacing = 50;

    const positions: StepPosition[] = steps.map((_, index) => {
      const x = (stepWidth + horizontalSpacing) * index + 50;
      const y = 100;
      
      return {
        x,
        y,
        width: stepWidth,
        height: stepHeight
      };
    });

    setStepPositions(positions);
  }, [steps]);

  // Generate connection path
  const generateConnectionPath = (connection: Connection): string => {
    const fromStepPos = stepPositions[connection.from.stepIndex];
    const toStepPos = stepPositions[connection.to.stepIndex];

    if (!fromStepPos || !toStepPos) return '';

    // Calculate field positions within steps
    const fromFieldY = fromStepPos.y + 60 + (connection.from.fieldIndex * 25);
    const toFieldY = toStepPos.y + 60 + (connection.to.fieldIndex * 25);

    const startX = fromStepPos.x + fromStepPos.width;
    const startY = fromFieldY;
    const endX = toStepPos.x;
    const endY = toFieldY;

    // Create smooth curve
    const controlPointDistance = Math.abs(endX - startX) * 0.5;
    const controlPoint1X = startX + controlPointDistance;
    const controlPoint2X = endX - controlPointDistance;

    return `M ${startX} ${startY} C ${controlPoint1X} ${startY}, ${controlPoint2X} ${endY}, ${endX} ${endY}`;
  };

  // Get connection color based on type and status
  const getConnectionColor = (connection: Connection): string => {
    if (selectedConnection === connection.id) return '#3b82f6'; // Blue
    if (hoveredConnection === connection.id) return '#10b981'; // Green
    if (connection.transform) return '#8b5cf6'; // Purple
    if (connection.isAutoGenerated) return '#6b7280'; // Gray
    return '#059669'; // Default green
  };

  // Field type icons
  const getFieldTypeIcon = (type: string): string => {
    const icons: Record<string, string> = {
      'text': 'ðŸ“', 'textarea': 'ðŸ“„', 'number': 'ðŸ”¢', 'email': 'ðŸ“§',
      'date': 'ðŸ“…', 'datetime': 'ðŸ•', 'select': 'ðŸ“‹', 'multiselect': 'â˜‘ï¸',
      'boolean': 'âœ…', 'file': 'ðŸ“Ž', 'url': 'ðŸ”—', 'json': 'ðŸ”§'
    };
    return icons[type] || 'ðŸ“';
  };

  // Handle connection interactions
  const handleConnectionClick = (connection: Connection, event: React.MouseEvent) => {
    event.stopPropagation();
    setSelectedConnection(connection.id);
    onConnectionClick?.(connection);
  };

  const handleConnectionMouseEnter = (connection: Connection) => {
    setHoveredConnection(connection.id);
    onConnectionHover?.(connection);
  };

  const handleConnectionMouseLeave = () => {
    setHoveredConnection(null);
    onConnectionHover?.(null);
  };

  // Connection statistics
  const connectionStats = useMemo(() => {
    return {
      total: connections.length,
      withTransforms: connections.filter(c => c.transform).length,
      autoGenerated: connections.filter(c => c.isAutoGenerated).length,
      typeMatches: connections.filter(c => c.from.fieldType === c.to.fieldType).length
    };
  }, [connections]);

  return (
    <div className={`relative w-full h-full min-h-[600px] bg-slate-50 rounded-lg overflow-auto ${className}`}>
      {/* Header with stats */}
      <div className="sticky top-0 z-20 bg-white border-b border-slate-200 p-4">
        <div className="flex items-center justify-between">
          <h3 className="font-semibold text-slate-900">Data Flow Visualization</h3>
          
          <div className="flex items-center gap-4 text-sm">
            <div className="flex items-center gap-1">
              <div className="w-3 h-3 bg-green-500 rounded-full"></div>
              <span className="text-slate-600">{connectionStats.total} connections</span>
            </div>
            <div className="flex items-center gap-1">
              <div className="w-3 h-3 bg-purple-500 rounded-full"></div>
              <span className="text-slate-600">{connectionStats.withTransforms} with transforms</span>
            </div>
            <div className="flex items-center gap-1">
              <div className="w-3 h-3 bg-gray-400 rounded-full"></div>
              <span className="text-slate-600">{connectionStats.autoGenerated} auto-generated</span>
            </div>
          </div>
        </div>
      </div>

      {/* Main visualization area */}
      <div ref={containerRef} className="relative p-6">
        {/* Steps */}
        <div className="relative">
          {steps.map((step, stepIndex) => {
            const position = stepPositions[stepIndex];
            if (!position) return null;

            return (
              <div
                key={step.id}
                className="absolute bg-white border-2 border-slate-200 rounded-lg shadow-sm"
                style={{
                  left: position.x,
                  top: position.y,
                  width: position.width,
                  height: position.height
                }}
              >
                {/* Step header */}
                <div className="p-4 border-b border-slate-100">
                  <div className="flex items-center gap-2">
                    <div className="w-6 h-6 bg-blue-100 rounded-full flex items-center justify-center text-sm font-semibold text-blue-700">
                      {stepIndex + 1}
                    </div>
                    <h4 className="font-medium text-slate-900 truncate">{step.title}</h4>
                  </div>
                </div>

                {/* Fields */}
                <div className="p-3 space-y-2 max-h-36 overflow-y-auto">
                  {/* Inputs */}
                  <div>
                    <div className="text-xs font-medium text-slate-500 mb-1">INPUTS</div>
                    {step.inputs.map((input, inputIndex) => (
                      <div key={inputIndex} className="flex items-center gap-2 text-xs py-1">
                        <div className="w-2 h-2 bg-blue-500 rounded-full flex-shrink-0"></div>
                        <span className="text-slate-700 truncate">
                          {getFieldTypeIcon(input.type)} {input.displayName || input.name}
                          {input.required && <span className="text-red-500 ml-1">*</span>}
                        </span>
                      </div>
                    ))}
                  </div>

                  {/* Outputs */}
                  <div>
                    <div className="text-xs font-medium text-slate-500 mb-1">OUTPUTS</div>
                    {step.outputs.map((output, outputIndex) => (
                      <div key={outputIndex} className="flex items-center gap-2 text-xs py-1">
                        <div className="w-2 h-2 bg-green-500 rounded-full flex-shrink-0"></div>
                        <span className="text-slate-700 truncate">
                          {getFieldTypeIcon(output.type)} {output.displayName || output.name}
                        </span>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            );
          })}
        </div>

        {/* SVG for connections */}
        <svg
          ref={svgRef}
          className="absolute inset-0 pointer-events-none"
          style={{
            width: Math.max(800, (stepPositions[stepPositions.length - 1]?.x || 0) + 350),
            height: Math.max(400, Math.max(...stepPositions.map(p => p.y + p.height)) + 100)
          }}
        >
          <defs>
            {/* Arrowhead markers */}
            <marker
              id="arrowhead-default"
              markerWidth="10"
              markerHeight="7"
              refX="9"
              refY="3.5"
              orient="auto"
            >
              <polygon points="0 0, 10 3.5, 0 7" fill="#059669" />
            </marker>
            <marker
              id="arrowhead-selected"
              markerWidth="10"
              markerHeight="7"
              refX="9"
              refY="3.5"
              orient="auto"
            >
              <polygon points="0 0, 10 3.5, 0 7" fill="#3b82f6" />
            </marker>
            <marker
              id="arrowhead-hovered"
              markerWidth="10"
              markerHeight="7"
              refX="9"
              refY="3.5"
              orient="auto"
            >
              <polygon points="0 0, 10 3.5, 0 7" fill="#10b981" />
            </marker>
            <marker
              id="arrowhead-transform"
              markerWidth="10"
              markerHeight="7"
              refX="9"
              refY="3.5"
              orient="auto"
            >
              <polygon points="0 0, 10 3.5, 0 7" fill="#8b5cf6" />
            </marker>
          </defs>

          {/* Connection paths */}
          {connections.map((connection) => {
            const path = generateConnectionPath(connection);
            const color = getConnectionColor(connection);
            const isSelected = selectedConnection === connection.id;
            const isHovered = hoveredConnection === connection.id;
            
            let markerId = 'arrowhead-default';
            if (isSelected) markerId = 'arrowhead-selected';
            else if (isHovered) markerId = 'arrowhead-hovered';
            else if (connection.transform) markerId = 'arrowhead-transform';

            return (
              <g key={connection.id}>
                {/* Connection line */}
                <path
                  d={path}
                  stroke={color}
                  strokeWidth={isSelected ? 3 : isHovered ? 2.5 : 2}
                  fill="none"
                  markerEnd={`url(#${markerId})`}
                  className={`pointer-events-auto cursor-pointer transition-all duration-200 ${
                    showAnimations ? 'animate-pulse' : ''
                  }`}
                  onClick={(e) => handleConnectionClick(connection, e)}
                  onMouseEnter={() => handleConnectionMouseEnter(connection)}
                  onMouseLeave={handleConnectionMouseLeave}
                />

                {/* Connection transform indicator */}
                {connection.transform && (
                  <g>
                    <circle
                      cx={stepPositions[connection.from.stepIndex]?.x + 140}
                      cy={stepPositions[connection.from.stepIndex]?.y + 60 + (connection.from.fieldIndex * 25)}
                      r="8"
                      fill="#8b5cf6"
                      className="pointer-events-auto cursor-pointer"
                      onClick={(e) => handleConnectionClick(connection, e)}
                    />
                    <text
                      x={stepPositions[connection.from.stepIndex]?.x + 140}
                      y={stepPositions[connection.from.stepIndex]?.y + 65 + (connection.from.fieldIndex * 25)}
                      textAnchor="middle"
                      className="text-xs fill-white font-semibold pointer-events-none"
                    >
                      T
                    </text>
                  </g>
                )}

                {/* Connection label */}
                {showLabels && isHovered && (
                  <g>
                    <rect
                      x={stepPositions[connection.from.stepIndex]?.x + 100}
                      y={stepPositions[connection.from.stepIndex]?.y + 45 + (connection.from.fieldIndex * 25)}
                      width="120"
                      height="20"
                      fill="rgba(0,0,0,0.8)"
                      rx="4"
                      className="pointer-events-none"
                    />
                    <text
                      x={stepPositions[connection.from.stepIndex]?.x + 160}
                      y={stepPositions[connection.from.stepIndex]?.y + 57 + (connection.from.fieldIndex * 25)}
                      textAnchor="middle"
                      className="text-xs fill-white pointer-events-none"
                    >
                      {connection.from.fieldName} â†’ {connection.to.fieldName}
                    </text>
                  </g>
                )}
              </g>
            );
          })}
        </svg>

        {/* Connection details panel */}
        {selectedConnection && (
          <div className="absolute top-4 right-4 bg-white border border-slate-200 rounded-lg shadow-lg p-4 w-80 z-30">
            {(() => {
              const connection = connections.find(c => c.id === selectedConnection);
              if (!connection) return null;

              return (
                <div>
                  <div className="flex items-center justify-between mb-3">
                    <h4 className="font-medium text-slate-900">Connection Details</h4>
                    <div className="flex items-center gap-2">
                      {connection.transform && (
                        <button
                          onClick={() => {/* Handle transform edit */}}
                          className="p-1 text-purple-600 hover:bg-purple-50 rounded"
                          title="Edit transform"
                        >
                          <Settings className="h-4 w-4" />
                        </button>
                      )}
                      {onConnectionRemove && (
                        <button
                          onClick={() => onConnectionRemove(connection.id)}
                          className="p-1 text-red-600 hover:bg-red-50 rounded"
                          title="Remove connection"
                        >
                          <Trash2 className="h-4 w-4" />
                        </button>
                      )}
                      <button
                        onClick={() => setSelectedConnection(null)}
                        className="p-1 text-slate-400 hover:bg-slate-50 rounded"
                      >
                        Ã—
                      </button>
                    </div>
                  </div>

                  <div className="space-y-3 text-sm">
                    <div>
                      <div className="font-medium text-slate-700 mb-1">From</div>
                      <div className="text-slate-600">
                        Step {connection.from.stepIndex + 1}: {connection.from.fieldName} ({connection.from.fieldType})
                      </div>
                    </div>

                    <div>
                      <div className="font-medium text-slate-700 mb-1">To</div>
                      <div className="text-slate-600">
                        Step {connection.to.stepIndex + 1}: {connection.to.fieldName} ({connection.to.fieldType})
                      </div>
                    </div>

                    {connection.transform && (
                      <div>
                        <div className="font-medium text-slate-700 mb-1">Transform</div>
                        <div className="text-slate-600 bg-purple-50 border border-purple-200 rounded p-2">
                          Type: {connection.transform.type}
                          {connection.transform.description && (
                            <div className="mt-1 text-xs">{connection.transform.description}</div>
                          )}
                        </div>
                      </div>
                    )}

                    {connection.isAutoGenerated && (
                      <div className="flex items-center gap-2 text-xs text-gray-600 bg-gray-50 rounded p-2">
                        <Zap className="h-3 w-3" />
                        Auto-generated connection
                      </div>
                    )}
                  </div>
                </div>
              );
            })()}
          </div>
        )}
      </div>
    </div>
  );
};