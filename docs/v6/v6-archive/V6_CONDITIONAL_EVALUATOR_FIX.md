# V6 ConditionalEvaluator Filter Pattern Fix

## Problem

When executing V6 workflows generated by IRToDSLCompiler, the runtime failed with:

```
Condition evaluation failed: Expected )
```

The problematic filter condition from step2:
```javascript
"condition": "((item.subject ?? '') + ' ' + (item.snippet ?? '')).toLowerCase().includes('complaint') || ..."
```

## Root Cause

The [ConditionalEvaluator](/Users/yaelomer/Documents/neuronforge/lib/pilot/ConditionalEvaluator.ts) uses a **safe expression parser** (no eval!) that only supports:

**Supported operations:**
- Comparison operators: `==`, `!=`, `>`, `>=`, `<`, `<=`
- Logical operators: `&&`, `||`, `!`
- Grouping: `( )`
- Literals: strings, numbers, booleans, null

**NOT supported (causes "Expected )" parse errors):**
- Method calls: `.toLowerCase()`, `.includes()`, `.indexOf()`
- String concatenation: `+`
- Nullish coalescing: `??`
- Complex parenthesized expressions with operators inside

The evaluator workflow:
1. **resolveVariablesInExpression** (line 141-170): Resolves `{{var}}` and `item.field` references to their values
2. **tokenize** (line 194-270): Splits expression into tokens (operators, literals, parentheses)
3. **parse** (line 275-372): Builds AST from tokens - this is where `.includes()` causes "Expected )" error
4. **evaluateAST** (line 377-401): Evaluates the AST

The tokenizer doesn't recognize `.` for method calls, so `item[0].includes('keyword')` fails during parsing.

## Solution: Pre-Computed Boolean Pattern

Instead of putting complex JavaScript expressions in filter conditions, **pre-compute** the boolean result in a map step, then filter on the boolean.

### Pattern 1: Keyword Matching (Case-Insensitive)

❌ **WRONG - Fails at runtime:**
```json
{
  "id": "step2",
  "type": "transform",
  "operation": "filter",
  "config": {
    "condition": "((item.subject ?? '') + ' ' + (item.snippet ?? '')).toLowerCase().includes('complaint')"
  }
}
```

✅ **CORRECT - Pre-compute, then filter:**
```json
{
  "id": "step2",
  "type": "transform",
  "operation": "map",
  "input": "{{step1.data}}",
  "config": {
    "expression": "[item, (((item.subject ?? '') + ' ' + (item.snippet ?? '')).toLowerCase().includes('complaint') || ((item.subject ?? '') + ' ' + (item.snippet ?? '')).toLowerCase().includes('refund'))]"
  }
},
{
  "id": "step3",
  "type": "transform",
  "operation": "filter",
  "input": "{{step2.data}}",
  "config": {
    "condition": "item[1] == true"
  }
},
{
  "id": "step4",
  "type": "transform",
  "operation": "map",
  "input": "{{step3.data}}",
  "config": {
    "expression": "item[0]"
  }
}
```

**How it works:**
1. **Map**: Execute JavaScript (toLowerCase, includes, etc.) to compute `[original_item, boolean_result]`
2. **Filter**: Simple comparison `item[1] == true` (no method calls!)
3. **Map**: Extract original item `item[0]`

### Pattern 2: Deduplication (Array Membership)

❌ **WRONG - Fails at runtime:**
```json
{
  "id": "step5",
  "type": "transform",
  "operation": "filter",
  "config": {
    "condition": "!{{existingIds.data}}.includes(item.id)"
  }
}
```

✅ **CORRECT - Pre-compute, then filter:**
```json
{
  "id": "step5",
  "type": "transform",
  "operation": "map",
  "input": "{{step4.data}}",
  "config": {
    "expression": "[item, !{{existingIds.data}}.includes(item.id)]"
  }
},
{
  "id": "step6",
  "type": "transform",
  "operation": "filter",
  "input": "{{step5.data}}",
  "config": {
    "condition": "item[1] == true"
  }
},
{
  "id": "step7",
  "type": "transform",
  "operation": "map",
  "input": "{{step6.data}}",
  "config": {
    "expression": "item[0]"
  }
}
```

## Implementation

### Updated IRToDSLCompiler Prompt

Modified [IRToDSLCompiler.ts:856-883](/Users/yaelomer/Documents/neuronforge/lib/agentkit/v6/compiler/IRToDSLCompiler.ts#L856-L883):

```typescript
**Filters**: IR.filters → transform with operation: "filter"
- CRITICAL - Condition syntax must be SIMPLE - evaluator does NOT support:
  - Method calls like .toLowerCase() or .includes()
  - String concatenation with +
  - Nullish coalescing ??
  - Parenthesized expressions with operators inside

- ✅ CORRECT filter patterns:
  1. For keyword matching (case-insensitive):
     Pre-compute match result in map, then filter on boolean:
     Step N-1 (map): {"expression": "[item, (item.subject.toLowerCase().includes('keyword') || item.snippet.toLowerCase().includes('keyword'))]"}
     Step N (filter): {"condition": "item[1] == true"}

  2. For simple field comparisons:
     {"condition": "item.status == 'active'"}
     {"condition": "item.score > 70"}

  3. For array membership:
     Pre-compute in prior map step, then filter on boolean:
     Step N-1 (map): {"expression": "[item, !existingIds.includes(item.id)]"}
     Step N (filter): {"condition": "item[1] == true"}
```

### Updated Deduplication Pattern

Modified [IRToDSLCompiler.ts:901-943](/Users/yaelomer/Documents/neuronforge/lib/agentkit/v6/compiler/IRToDSLCompiler.ts#L901-L943):

```typescript
**Deduplication** (CRITICAL):
When IR has lookup data source with role="lookup", use pre-computed boolean pattern:

✅ CORRECT - Pre-compute membership test, then filter on boolean:
{
  "id": "step5",
  "type": "transform",
  "operation": "map",
  "input": "{{step2.data}}",  // New filtered items
  "config": {"expression": "[item, !{{step4.data}}.includes(item.id)]"}  // [item, isNew]
},
{
  "id": "step6",
  "type": "transform",
  "operation": "filter",
  "input": "{{step5.data}}",
  "config": {"condition": "item[1] == true"}  // Keep only new items
},
{
  "id": "step7",
  "type": "transform",
  "operation": "map",
  "input": "{{step6.data}}",
  "config": {"expression": "item[0]"}  // Extract original item
}

❌ WRONG - Do NOT use: "!{{step4.data}}.includes(item.id)" - .includes() is method call, evaluator can't parse
```

## Testing Results

### Test: Gmail Complaints Workflow

**Command:**
```bash
npx tsx test-improved-llm-compiler.ts
```

**Result:** ✅ SUCCESS
- Generated 11-step workflow
- All filter conditions use simple pattern: `item[1] == true`
- No scatter_gather (simple deduplication)
- Column positions consistent
- No post-validation errors

**Generated workflow structure:**
1. Search Gmail
2. Map: Pre-compute keyword match → `[item, boolean]`
3. Filter: `item[1] == true`
4. Map: Extract `item[0]`
5. Read existing sheet rows
6. Map: Extract ID column
7. Map: Pre-compute membership → `[item, !existingIds.includes(id)]`
8. Filter: `item[1] == true`
9. Map: Extract `item[0]`
10. Map: Render rows
11. Append to sheet

## Impact

### Before Fix
- ❌ Complex filter conditions with method calls
- ❌ Runtime "Expected )" parsing errors
- ❌ Workflows fail during execution

### After Fix
- ✅ Simple boolean filter conditions
- ✅ All JavaScript logic in map operations (which support full JavaScript)
- ✅ Workflows execute successfully
- ✅ No parser errors

## Related Files

- [ConditionalEvaluator.ts](/Users/yaelomer/Documents/neuronforge/lib/pilot/ConditionalEvaluator.ts) - Runtime filter evaluator
- [IRToDSLCompiler.ts](/Users/yaelomer/Documents/neuronforge/lib/agentkit/v6/compiler/IRToDSLCompiler.ts) - LLM compiler with updated prompt
- [test-improved-llm-compiler.ts](/Users/yaelomer/Documents/neuronforge/test-improved-llm-compiler.ts) - Test script

## Key Insight

The ConditionalEvaluator is designed for **safety** (no eval) and **simplicity** (structured conditions). Complex runtime logic should be in **map operations** (which execute JavaScript), while **filter operations** should only contain simple comparisons.

This separation of concerns:
- Makes workflows more readable (map = compute, filter = decide)
- Ensures security (no eval in conditions)
- Enables static analysis and validation
- Prevents runtime parsing errors
